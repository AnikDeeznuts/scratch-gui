{"version":3,"file":"js/addon-entry-editor-stepping.js","sources":["webpack://GUI/./src/addons/addons/debugger/module.js","webpack://GUI/./src/addons/addons/editor-stepping/_runtime_entry.js","webpack://GUI/./src/addons/addons/editor-stepping/highlighter.js","webpack://GUI/./src/addons/addons/editor-stepping/userscript.js"],"sourcesContent":["import EventTarget from \"../../event-target.js\"; /* inserted by pull.js */\n\n// https://github.com/LLK/scratch-vm/blob/bb352913b57991713a5ccf0b611fda91056e14ec/src/engine/thread.js#L198\nconst STATUS_RUNNING = 0;\nconst STATUS_PROMISE_WAIT = 1;\nconst STATUS_YIELD = 2;\nconst STATUS_YIELD_TICK = 3;\nconst STATUS_DONE = 4;\n\nlet vm;\n\nlet paused = false;\nlet pausedThreadState = new WeakMap();\nlet pauseNewThreads = false;\n\nlet steppingThread = null;\n\nconst eventTarget = new EventTarget();\n\nlet audioContextStateChange = Promise.resolve();\n\nexport const isPaused = () => paused;\n\nconst pauseThread = (thread) => {\n  if (thread.updateMonitor || pausedThreadState.has(thread)) {\n    // Thread is already paused or shouldn't be paused.\n    return;\n  }\n\n  const pauseState = {\n    time: vm.runtime.currentMSecs,\n    status: thread.status,\n  };\n  pausedThreadState.set(thread, pauseState);\n\n  // Pausing a thread now works by just setting its status to STATUS_PROMISE_WAIT.\n  // At the start of each frame, we make sure each paused thread is still paused.\n  // This is really the best way to implement this.\n  // Converting thread.status into a getter/setter causes Scratch's sequencer to permanently\n  //    perform significantly slower in some projects. I think this is because it causes some\n  //    very hot functions to be deoptimized.\n  // Trapping sequencer.stepThread to no-op for a paused thread causes Scratch's sequencer\n  //    to waste 24ms of CPU time every frame because it thinks a thread is running.\n  thread.status = STATUS_PROMISE_WAIT;\n};\n\nconst ensurePausedThreadIsStillPaused = (thread) => {\n  if (thread.status === STATUS_DONE) {\n    // If a paused thread is finished by single stepping, let it keep being done.\n    return;\n  }\n  const pauseState = pausedThreadState.get(thread);\n  if (pauseState) {\n    if (thread.status !== STATUS_PROMISE_WAIT) {\n      // We'll record the change so we can properly resume the thread, but the thread must still be paused for now.\n      pauseState.status = thread.status;\n      thread.status = STATUS_PROMISE_WAIT;\n    }\n  }\n};\n\nconst setSteppingThread = (thread) => {\n  steppingThread = thread;\n};\n\nconst compensateForTimePassedWhilePaused = (thread, pauseState) => {\n  // TW: Compiled threads store their timer in a different place.\n  if (thread.timer) {\n    thread.timer.startTime += vm.runtime.currentMSecs - pauseState.time;\n  }\n  const stackFrame = thread.peekStackFrame();\n  if (stackFrame && stackFrame.executionContext && stackFrame.executionContext.timer) {\n    stackFrame.executionContext.timer.startTime += vm.runtime.currentMSecs - pauseState.time;\n  }\n};\n\nconst stepUnsteppedThreads = (lastSteppedThread) => {\n  // If we paused in the middle of a tick, we need to make sure to step the scripts that didn't get\n  // stepped in that tick to avoid affecting project behavior.\n  const threads = vm.runtime.threads;\n  const startingIndex = getThreadIndex(lastSteppedThread);\n  if (startingIndex !== -1) {\n    for (let i = startingIndex; i < threads.length; i++) {\n      const thread = threads[i];\n      const status = thread.status;\n      if (status === STATUS_RUNNING || status === STATUS_YIELD || status === STATUS_YIELD_TICK) {\n        vm.runtime.sequencer.activeThread = thread;\n        vm.runtime.sequencer.stepThread(thread);\n      }\n    }\n  }\n};\n\nexport const setPaused = (_paused) => {\n  const didChange = paused !== _paused;\n  if (didChange) {\n    paused = _paused;\n    eventTarget.dispatchEvent(new CustomEvent(\"change\"));\n  }\n\n  // Don't check didChange as new threads could've started that we need to pause.\n  if (paused) {\n    audioContextStateChange = audioContextStateChange.then(() => {\n      return vm.runtime.audioEngine.audioContext.suspend();\n    });\n    if (!vm.runtime.ioDevices.clock._paused) {\n      vm.runtime.ioDevices.clock.pause();\n    }\n    vm.runtime.threads.forEach(pauseThread);\n\n    const activeThread = vm.runtime.sequencer.activeThread;\n    if (activeThread) {\n      setSteppingThread(activeThread);\n      eventTarget.dispatchEvent(new CustomEvent(\"step\"));\n    }\n  }\n\n  // Only run unpausing logic when pause state changed to avoid unnecessary work\n  if (!paused && didChange) {\n    audioContextStateChange = audioContextStateChange.then(() => {\n      return vm.runtime.audioEngine.audioContext.resume();\n    });\n    vm.runtime.ioDevices.clock.resume();\n    for (const thread of vm.runtime.threads) {\n      const pauseState = pausedThreadState.get(thread);\n      if (pauseState) {\n        compensateForTimePassedWhilePaused(thread, pauseState);\n        thread.status = pauseState.status;\n      }\n    }\n    pausedThreadState = new WeakMap();\n\n    const lastSteppedThread = steppingThread;\n    // This must happen after the \"change\" event is fired to fix https://github.com/ScratchAddons/ScratchAddons/issues/4281\n    stepUnsteppedThreads(lastSteppedThread);\n    steppingThread = null;\n  }\n};\n\nexport const onPauseChanged = (listener) => {\n  eventTarget.addEventListener(\"change\", () => listener(paused));\n};\n\nexport const onSingleStep = (listener) => {\n  eventTarget.addEventListener(\"step\", listener);\n};\n\nexport const getRunningThread = () => steppingThread;\n\n// A modified version of this function\n// https://github.com/LLK/scratch-vm/blob/0e86a78a00db41af114df64255e2cd7dd881329f/src/engine/sequencer.js#L179\n// Returns if we should continue executing this thread.\nconst singleStepThread = (thread) => {\n  if (thread.status === STATUS_DONE) {\n    return false;\n  }\n  // TW: Can't single-step compiled threads\n  if (thread.isCompiled) {\n    return false;\n  }\n\n  const currentBlockId = thread.peekStack();\n  if (!currentBlockId) {\n    thread.popStack();\n\n    if (thread.stack.length === 0) {\n      thread.status = STATUS_DONE;\n      return false;\n    }\n  }\n\n  pauseNewThreads = true;\n  vm.runtime.sequencer.activeThread = thread;\n\n  /*\n    We need to call execute(this, thread) like the original sequencer. We don't\n    have access to that method, so we need to force the original stepThread to run\n    execute for us then exit before it tries to run more blocks.\n    So, we make `thread.blockGlowInFrame = ...` throw an exception, so this line:\n    https://github.com/LLK/scratch-vm/blob/bb352913b57991713a5ccf0b611fda91056e14ec/src/engine/sequencer.js#L214\n    will end the function early. We then have to set it back to normal afterward.\n\n    Why are we here just to suffer?\n  */\n  const specialError = [\"special error used by Scratch Addons for implementing single-stepping\"];\n  Object.defineProperty(thread, \"blockGlowInFrame\", {\n    set(_block) {\n      throw specialError;\n    },\n  });\n\n  try {\n    thread.status = STATUS_RUNNING;\n\n    // Restart the warp timer on each step.\n    // If we don't do this, Scratch will think a lot of time has passed and may yield this thread.\n    if (thread.warpTimer) {\n      thread.warpTimer.start();\n    }\n\n    try {\n      vm.runtime.sequencer.stepThread(thread);\n    } catch (err) {\n      if (err !== specialError) throw err;\n    }\n\n    if (thread.status !== STATUS_RUNNING) {\n      return false;\n    }\n\n    if (thread.peekStack() === currentBlockId) {\n      thread.goToNextBlock();\n    }\n\n    while (!thread.peekStack()) {\n      thread.popStack();\n\n      if (thread.stack.length === 0) {\n        thread.status = STATUS_DONE;\n        return false;\n      }\n\n      const stackFrame = thread.peekStackFrame();\n\n      if (stackFrame.isLoop) {\n        if (thread.peekStackFrame().warpMode) {\n          continue;\n        } else {\n          return false;\n        }\n      } else if (stackFrame.waitingReporter) {\n        return false;\n      }\n\n      thread.goToNextBlock();\n    }\n\n    return true;\n  } finally {\n    pauseNewThreads = false;\n    vm.runtime.sequencer.activeThread = null;\n    Object.defineProperty(thread, \"blockGlowInFrame\", {\n      value: currentBlockId,\n      configurable: true,\n      enumerable: true,\n      writable: true,\n    });\n\n    // Strictly this doesn't seem to be necessary, but let's make sure the thread is still paused after we step it.\n    if (thread.status !== STATUS_DONE) {\n      thread.status = STATUS_PROMISE_WAIT;\n    }\n  }\n};\n\nconst getRealStatus = (thread) => {\n  const pauseState = pausedThreadState.get(thread);\n  if (pauseState) {\n    return pauseState.status;\n  }\n  return thread.status;\n};\n\nconst getThreadIndex = (thread) => {\n  // We can't use vm.runtime.threads.indexOf(thread) because threads can be restarted.\n  // This can happens when, for example, a \"when I receive message1\" script broadcasts message1.\n  // The object in runtime.threads is replaced when this happens.\n  if (!thread) return -1;\n  return vm.runtime.threads.findIndex(\n    (otherThread) =>\n      otherThread.target === thread.target &&\n      otherThread.topBlock === thread.topBlock &&\n      otherThread.stackClick === thread.stackClick &&\n      otherThread.updateMonitor === thread.updateMonitor\n  );\n};\n\nconst findNewSteppingThread = (startingIndex) => {\n  const threads = vm.runtime.threads;\n  for (let i = startingIndex; i < threads.length; i++) {\n    const possibleNewThread = threads[i];\n    if (possibleNewThread.updateMonitor) {\n      // Never single-step monitor update threads.\n      continue;\n    }\n    // TW: Can't single-step compiled threads\n    if (possibleNewThread.isCompiled) {\n      continue;\n    }\n    const status = getRealStatus(possibleNewThread);\n    if (status === STATUS_RUNNING || status === STATUS_YIELD || status === STATUS_YIELD_TICK) {\n      // Thread must not be running for single stepping to work.\n      pauseThread(possibleNewThread);\n      return possibleNewThread;\n    }\n  }\n  return null;\n};\n\nexport const singleStep = () => {\n  if (steppingThread) {\n    const pauseState = pausedThreadState.get(steppingThread);\n    // We can assume pauseState is defined as any single stepping threads must already be paused.\n\n    // Make it look like no time has passed\n    compensateForTimePassedWhilePaused(steppingThread, pauseState);\n    pauseState.time = vm.runtime.currentMSecs;\n\n    // Execute the block\n    const continueExecuting = singleStepThread(steppingThread);\n\n    if (!continueExecuting) {\n      // Try to move onto the next thread\n      steppingThread = findNewSteppingThread(getThreadIndex(steppingThread) + 1);\n    }\n  }\n\n  // If we don't have a thread, than we are between VM steps and should search for a new thread\n  if (!steppingThread) {\n    setSteppingThread(findNewSteppingThread(0));\n\n    // End of VM step, emulate one frame of time passing.\n    vm.runtime.ioDevices.clock._pausedTime += vm.runtime.currentStepTime;\n    // Skip all sounds forward by vm.runtime.currentStepTime milliseconds so it's as\n    //  if they where playing for one frame.\n    const audioContext = vm.runtime.audioEngine.audioContext;\n    for (const target of vm.runtime.targets) {\n      for (const soundId of Object.keys(target.sprite.soundBank.soundPlayers)) {\n        const soundPlayer = target.sprite.soundBank.soundPlayers[soundId];\n        if (soundPlayer.outputNode) {\n          soundPlayer.outputNode.stop(audioContext.currentTime);\n          soundPlayer._createSource();\n          soundPlayer.outputNode.start(\n            audioContext.currentTime,\n            audioContext.currentTime - soundPlayer.startingUntil + vm.runtime.currentStepTime / 1000\n          );\n          soundPlayer.startingUntil -= vm.runtime.currentStepTime / 1000;\n        }\n      }\n    }\n    // Move all threads forward one frame in time. For blocks like `wait () seconds`\n    for (const thread of vm.runtime.threads) {\n      if (pausedThreadState.has(thread)) {\n        pausedThreadState.get(thread).time += vm.runtime.currentStepTime;\n      }\n    }\n\n    // Try to run edge activated hats\n    pauseNewThreads = true;\n\n    const hats = vm.runtime._hats;\n    for (const hatType in hats) {\n      if (!Object.prototype.hasOwnProperty.call(hats, hatType)) continue;\n      const hat = hats[hatType];\n      if (hat.edgeActivated) {\n        vm.runtime.startHats(hatType);\n      }\n    }\n\n    pauseNewThreads = false;\n  }\n\n  eventTarget.dispatchEvent(new CustomEvent(\"step\"));\n};\n\nexport const setup = (_vm) => {\n  if (vm) {\n    return;\n  }\n\n  vm = _vm;\n\n  const originalStepThreads = vm.runtime.sequencer.stepThreads;\n  vm.runtime.sequencer.stepThreads = function () {\n    if (isPaused()) {\n      for (const thread of this.runtime.threads) {\n        ensurePausedThreadIsStillPaused(thread);\n      }\n    }\n    return originalStepThreads.call(this);\n  };\n\n  // Unpause when green flag\n  const originalGreenFlag = vm.runtime.greenFlag;\n  vm.runtime.greenFlag = function () {\n    setPaused(false);\n    return originalGreenFlag.call(this);\n  };\n\n  // Disable edge-activated hats and hats like \"when key pressed\" while paused.\n  const originalStartHats = vm.runtime.startHats;\n  vm.runtime.startHats = function (...args) {\n    const hat = args[0];\n    // These hats can be manually started by the user when paused or while single stepping.\n    const isUserInitiated = hat === \"event_whenbroadcastreceived\" || hat === \"control_start_as_clone\";\n    if (pauseNewThreads) {\n      if (!isUserInitiated && !this.getIsEdgeActivatedHat(hat)) {\n        return [];\n      }\n      const newThreads = originalStartHats.apply(this, args);\n      for (const thread of newThreads) {\n        pauseThread(thread);\n      }\n      return newThreads;\n    } else if (paused && !isUserInitiated) {\n      return [];\n    }\n    return originalStartHats.apply(this, args);\n  };\n\n  // Paused threads should not be counted as running when updating GUI state.\n  const originalGetMonitorThreadCount = vm.runtime._getMonitorThreadCount;\n  vm.runtime._getMonitorThreadCount = function (threads) {\n    let count = originalGetMonitorThreadCount.call(this, threads);\n    if (paused) {\n      for (const thread of threads) {\n        if (pausedThreadState.has(thread)) {\n          count++;\n        }\n      }\n    }\n    return count;\n  };\n};\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","const SVG_NS = \"http://www.w3.org/2000/svg\";\n\nconst containerSvg = document.createElementNS(SVG_NS, \"svg\");\n// unfortunately we can't use display: none on this as that breaks filters\ncontainerSvg.style.position = \"fixed\";\ncontainerSvg.style.top = \"-999999px\";\ncontainerSvg.style.width = \"0\";\ncontainerSvg.style.height = \"0\";\ndocument.body.appendChild(containerSvg);\n\nlet nextGlowerId = 0;\n\nconst highlightsPerElement = new WeakMap();\n\nconst getHighlightersForElement = (element) => {\n  if (!highlightsPerElement.get(element)) {\n    highlightsPerElement.set(element, new Set());\n  }\n  return highlightsPerElement.get(element);\n};\n\nconst updateHighlight = (element, highlighters) => {\n  let result;\n  for (const i of highlighters) {\n    if (!result || i.priority > result.priority) {\n      result = i;\n    }\n  }\n  if (result) {\n    element.style.filter = result.filter;\n  } else {\n    element.style.filter = \"\";\n  }\n};\n\nconst addHighlight = (element, highlighter) => {\n  const highlighters = getHighlightersForElement(element);\n  highlighters.add(highlighter);\n  updateHighlight(element, highlighters);\n};\n\nconst removeHighlight = (element, highlighter) => {\n  const highlighters = getHighlightersForElement(element);\n  highlighters.delete(highlighter);\n  updateHighlight(element, highlighters);\n};\n\nclass Highlighter {\n  constructor(priority, color) {\n    this.priority = priority;\n\n    const id = `sa_glower_filter${nextGlowerId++}`;\n    this.filter = `url(\"#${id}\")`;\n\n    this.previousElements = new Set();\n\n    const filterElement = document.createElementNS(SVG_NS, \"filter\");\n    filterElement.id = id;\n    filterElement.setAttribute(\"width\", \"180%\");\n    filterElement.setAttribute(\"height\", \"160%\");\n    filterElement.setAttribute(\"x\", \"-40%\");\n    filterElement.setAttribute(\"y\", \"-30%\");\n\n    const filterBlur = document.createElementNS(SVG_NS, \"feGaussianBlur\");\n    filterBlur.setAttribute(\"in\", \"SourceGraphic\");\n    filterBlur.setAttribute(\"stdDeviation\", \"4\");\n    filterElement.appendChild(filterBlur);\n\n    const filterTransfer = document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filterTransfer.setAttribute(\"result\", \"outBlur\");\n    filterElement.appendChild(filterTransfer);\n\n    const filterTransferTable = document.createElementNS(SVG_NS, \"feFuncA\");\n    filterTransferTable.setAttribute(\"type\", \"table\");\n    filterTransferTable.setAttribute(\"tableValues\", \"0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\");\n    filterTransfer.appendChild(filterTransferTable);\n\n    const filterFlood = document.createElementNS(SVG_NS, \"feFlood\");\n    filterFlood.setAttribute(\"flood-opacity\", \"1\");\n    filterFlood.setAttribute(\"result\", \"outColor\");\n    filterElement.appendChild(filterFlood);\n    this.filterFlood = filterFlood;\n\n    const filterComposite = document.createElementNS(SVG_NS, \"feComposite\");\n    filterComposite.setAttribute(\"in\", \"outColor\");\n    filterComposite.setAttribute(\"in2\", \"outBlur\");\n    filterComposite.setAttribute(\"operator\", \"in\");\n    filterComposite.setAttribute(\"result\", \"outGlow\");\n    filterElement.appendChild(filterComposite);\n\n    const filterFinalComposite = document.createElementNS(SVG_NS, \"feComposite\");\n    filterFinalComposite.setAttribute(\"in\", \"SourceGraphic\");\n    filterFinalComposite.setAttribute(\"in2\", \"outGlow\");\n    filterFinalComposite.setAttribute(\"operator\", \"over\");\n    filterElement.appendChild(filterFinalComposite);\n\n    containerSvg.appendChild(filterElement);\n    this.setColor(color);\n  }\n\n  setColor(color) {\n    this.filterFlood.setAttribute(\"flood-color\", color);\n  }\n\n  setGlowingThreads(threads) {\n    const elementsToHighlight = new Set();\n    const workspace = Blockly.getMainWorkspace();\n\n    if (workspace) {\n      for (const thread of threads) {\n        thread.stack.forEach((blockId) => {\n          const block = workspace.getBlockById(blockId);\n          if (!block) {\n            return;\n          }\n          const childblock = thread.stack.find((i) => {\n            let b = block;\n            while (b.childBlocks_.length) {\n              b = b.childBlocks_[b.childBlocks_.length - 1];\n              if (i === b.id) return true;\n            }\n            return false;\n          });\n          if (!childblock && block.svgPath_) {\n            const svgPath = block.svgPath_;\n            elementsToHighlight.add(svgPath);\n          }\n        });\n      }\n    }\n\n    for (const element of this.previousElements) {\n      if (!elementsToHighlight.has(element)) {\n        removeHighlight(element, this);\n      }\n    }\n    for (const element of elementsToHighlight) {\n      if (!this.previousElements.has(element)) {\n        addHighlight(element, this);\n      }\n    }\n    this.previousElements = elementsToHighlight;\n  }\n}\n\nexport default Highlighter;\n","import { getRunningThread } from \"../debugger/module.js\";\nimport Highlighter from \"./highlighter.js\";\n\nexport default async function ({ addon, console }) {\n  const vm = addon.tab.traps.vm;\n\n  const highlighter = new Highlighter(0, addon.settings.get(\"highlight-color\"));\n  addon.settings.addEventListener(\"change\", () => {\n    highlighter.setColor(addon.settings.get(\"highlight-color\"));\n  });\n\n  addon.self.addEventListener(\"disabled\", () => {\n    highlighter.setGlowingThreads([]);\n  });\n\n  const oldStep = vm.runtime._step;\n  vm.runtime._step = function (...args) {\n    oldStep.call(this, ...args);\n    if (!addon.self.disabled) {\n      const runningThread = getRunningThread();\n      const threads = vm.runtime.threads.filter(\n        (thread) => thread !== runningThread && !thread.target.blocks.forceNoGlow && !thread.isCompiled\n      );\n      highlighter.setGlowingThreads(threads);\n    }\n  };\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvaA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;ACjJA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;A","sourceRoot":""}